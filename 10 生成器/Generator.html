<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generator</title>
</head>
<body>
    <script>
        // Generator 是一种更强大的遍历器生成函数，yield 语句用来暂停函数执行，并返回一个值。next() 方法可以恢复函数执行。
        // 1.基本定义
        function* gen() {
            yield 1;
            yield 2;
            yield 3;
        }

        let g = gen(); // 调用 Generator 函数，返回一个遍历器对象
        console.log(g.next()); // { value: 1, done: false }
        console.log(g.next()); // { value: 2, done: false }
        console.log(g.next()); // { value: 3, done: false }
        console.log(g.next()); // { value: undefined, done: true }

        // 2.Generator 函数的状态
        // Generator 函数有多种状态：执行中（suspendedStart）、暂停（suspendedYield）、执行完成（completed）
        function* gen2() {
            console.log('开始');
            yield 1; // 暂停点
            console.log('继续');
            yield 2; // 暂停点
            console.log('结束');
        }

        let g2 = gen2(); // 调用 Generator 函数，返回一个遍历器对象，此时函数并未执行
        console.log(g2.next()); // 开始 \n { value: 1, done: false }
        console.log(g2.next()); // 继续 \n { value: 2, done: false }
        console.log(g2.next()); // 结束 \n { value: undefined, done: true }

        // 3.向 Generator 函数传值
        function* gen3() {
            let a = yield 1; 
            let b = yield a + 2;
            yield b + 3;
        }

        // 并不能简单地理解为 a = 1，而是应该理解为 a 需要从 next() 方法传入的值来赋值，yield 1 是暂停点
        // 如下顺序可以更方便理解 ：
        // function* gen4() {
        //     yield 1
        //     let a = <next() 传入的值>; 
        //     yield a + 2
        //     let b = <next() 传入的值>;
        //     yield b + 3;
        // }

        let g3 = gen3();
        console.log(g3.next()); // { value: 1, done: false }
        console.log(g3.next(10)); // { value: 12, done: false }，a 接收到了 10
        console.log(g3.next(20)); // { value: 23, done: false }，b 接收到了 20
        console.log(g3.next()); // { value: undefined, done: true }

        /**此处做简单解释
         * 第一次调用 g3.next()，函数执行到第一个 yield，返回 1。此时a的赋值被暂停，等待下一次调用 next()。
         * 第二次调用 g3.next(10)，10 被传入函数内部，赋值给 a，然后函数继续执行到下一个 yield，返回 a + 2，即 12。
         * 但是b的赋值同样被暂停，等待下一次调用 next()。
         * 第三次调用 g3.next(20)，20 被传入函数内部，赋值给 b，然后函数继续执行到下一个 yield，返回 b + 3，即 23。
         * 最后一次调用 g3.next()，函数执行完毕，返回 { value: undefined, done: true }。
         */

        //  PS：yield关键字后面的表达式不能换行显示,否则会报错。


        // 应用示例，使用 Generator 函数和yield语句控制异步操作的执行顺序，异步代码看起来像同步代码

        function* load(){
            loadUI();
            yield showData();
            hideUI();
        }

        const loader = load();
        loader.next(); // 加载界面

        function loadUI(){
         console.log('加载界面');   
        }

        function showData(data){
         setTimeout(() => {
            console.log('显示数据：' + data); 
            loader.next(); // 隐藏界面
         }, 1000);
        }
        function hideUI(){
         console.log('隐藏界面');   
        }
        
    </script>
</body>
</html>